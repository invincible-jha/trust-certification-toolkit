# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2026 MuVeraAI Corporation
"""
ReportGenerator — produces Markdown and JSON certification reports from
a CertificationResult. All output is local; no data is sent anywhere.
"""

from __future__ import annotations

import json
from typing import Literal

from aumos_certify.levels import get_level_definition
from aumos_certify.types import CertificationResult, ConformanceStatus


class ReportGenerator:
    """
    Generates a certification report in Markdown or JSON format.

    All report generation is offline — no network communication.
    """

    def generate(
        self,
        result: CertificationResult,
        format: Literal["md", "json"] = "md",
    ) -> str:
        """
        Generate a certification report.

        Args:
            result: The CertificationResult to report on.
            format: Output format — "md" for Markdown, "json" for JSON.

        Returns:
            The formatted report as a string.
        """
        if format == "json":
            return self._generate_json(result)
        return self._generate_markdown(result)

    def _generate_markdown(self, result: CertificationResult) -> str:
        run = result.run_result
        level_label = (
            result.achieved_level.value.capitalize()
            if result.achieved_level is not None
            else "None"
        )
        level_def = (
            get_level_definition(result.achieved_level)
            if result.achieved_level is not None
            else None
        )

        lines: list[str] = [
            "# AumOS Certification Report",
            "",
            "> **This is a self-assessment report.** It is generated locally and reflects",
            "> the implementer's own test results. The badge is labeled \"Self-Assessed\".",
            "",
            "---",
            "",
            "## Summary",
            "",
            f"| Field | Value |",
            f"|---|---|",
            f"| Implementation | {run.implementation_name} |",
            f"| Run ID | `{run.run_id}` |",
            f"| Date | {run.started_at.strftime('%Y-%m-%d %H:%M UTC')} |",
            f"| Overall Score | {result.score_pct:.1f}% |",
            f"| Achieved Level | **{level_label}** |",
        ]

        if level_def is not None:
            lines.append(f"| Badge Color | `{level_def.badge_color}` |")
            lines.append(f"| Display Name | {level_def.display_name} |")

        lines += [
            "",
            "---",
            "",
            "## Protocol Results",
            "",
        ]

        for protocol_id in run.protocols_run:
            protocol_result = run.protocol_results.get(protocol_id)
            if protocol_result is None:
                continue

            score_pct = protocol_result.score * 100
            lines += [
                f"### {protocol_id.upper()}",
                "",
                f"**Score:** {score_pct:.1f}% "
                f"({protocol_result.passed}/{protocol_result.total} checks passed)",
                "",
                "| Check ID | Description | Level | Status | Message |",
                "|---|---|---|---|---|",
            ]

            for check in protocol_result.checks:
                status_icon = {
                    ConformanceStatus.PASS: "PASS",
                    ConformanceStatus.FAIL: "FAIL",
                    ConformanceStatus.SKIP: "SKIP",
                    ConformanceStatus.ERROR: "ERROR",
                }.get(check.status, check.status.value)

                message = check.message or ""
                lines.append(
                    f"| `{check.check_id}` | {check.description} "
                    f"| {check.conformance_level} | {status_icon} | {message} |"
                )

            lines.append("")

        lines += [
            "---",
            "",
            "## Level Detail",
            "",
        ]

        for level_id, detail in result.level_detail.items():
            assert isinstance(detail, dict)
            satisfied = detail.get("satisfied", False)
            status = "ACHIEVED" if satisfied else "not satisfied"
            lines += [
                f"### {level_id.capitalize()} — {status}",
                "",
                f"- Minimum score: {detail.get('minimum_score_pct')}%",
                f"- Actual score: {detail.get('actual_score_pct')}%",
                f"- Required protocols: {', '.join(detail.get('required_protocols', []))}",
            ]
            missing = detail.get("missing_protocols", [])
            if missing:
                lines.append(f"- Missing protocols: {', '.join(missing)}")
            lines.append("")

        lines += [
            "---",
            "",
            "*Generated by aumos-certify. Self-assessment only — not an official audit.*",
            "",
            "Apache License, Version 2.0",
            "See https://www.apache.org/licenses/LICENSE-2.0 for full text.",
            "Copyright (c) 2026 MuVeraAI Corporation",
        ]

        return "\n".join(lines)

    def _generate_json(self, result: CertificationResult) -> str:
        run = result.run_result

        protocol_results_data = {}
        for protocol_id, protocol_result in run.protocol_results.items():
            protocol_results_data[protocol_id] = {
                "score_pct": round(protocol_result.score * 100, 2),
                "passed": protocol_result.passed,
                "failed": protocol_result.failed,
                "skipped": protocol_result.skipped,
                "errors": protocol_result.errors,
                "checks": [
                    {
                        "check_id": c.check_id,
                        "description": c.description,
                        "conformance_level": c.conformance_level,
                        "status": c.status.value,
                        "message": c.message,
                    }
                    for c in protocol_result.checks
                ],
            }

        report_data = {
            "schema_version": "1.0",
            "report_type": "self_assessment",
            "implementation_name": run.implementation_name,
            "run_id": run.run_id,
            "started_at": run.started_at.isoformat(),
            "completed_at": run.completed_at.isoformat(),
            "overall_score_pct": round(result.score_pct, 2),
            "achieved_level": result.achieved_level.value if result.achieved_level else None,
            "required_protocols_satisfied": result.required_protocols_satisfied,
            "missing_protocols": result.missing_protocols,
            "protocols_run": run.protocols_run,
            "protocol_results": protocol_results_data,
            "level_detail": result.level_detail,
            "notice": (
                "This is a self-assessment report generated locally by aumos-certify. "
                "It is not an official third-party audit. The badge is labeled 'Self-Assessed'."
            ),
        }

        return json.dumps(report_data, indent=2)
